# JavaCollectionsFrameWork
Code from Stepik Java course

## Иерархия классов Collection Framework

![Иерархия1.png](imagesForReadme/%D0%98%D0%B5%D1%80%D0%B0%D1%80%D1%85%D0%B8%D1%8F1.png)
**Iterable** - интерфейс, который позволяет перебирать элементы коллекции циклом for each

**Collection** - интерфейс, от которого наследуются Set и List

Основные реализации List:
- **ArrayList**
- **LinkedList**

Основные реализации Set:
- **HashSet**
- **TreeSet**

## ArrayList (динамический массив)
Алгоритмическая сложность операций в коллекции **ArrayList**

Плюсы:
- Получение элемента по индексу - **O(1)**
- Вставка элемента в конец списка - **O(1)**

Минусы:
- Удаление элемента - **O(N)**
- Вставка элемента в середину или начало списка - **O(N)**
- При удалении элементов мы не меняем размер массива, только меняем size. Может возникнуть утечка памяти


## LinkedList (Связный список)
Внутри LinkedList есть класс Node

```java
class Node {
	Node previous; // предыдущий элемент
	T value; // текущий элемент (значение)
	Node next; // следующий элемент 
}
```
Алгоритмическая сложность операций в коллекции **LinkedList**

Плюсы:
- Вставка в начало, середину или конец коллекции- **O(1)**
- Удаление элемента из коллекции - **O(1)**

Минусы:
- Получение элемента по индексу - **O(n)**

## HashSet
### Коллекция HashSet в своей основе использует коллекцию HashMap, где добавляемые объекты хранятся в виде ключей, а в качестве значения используется `Object object`

**### !!! В HashSet нет методов, обращающихся к элементу по индексу, таких как:**
- **get(index)**
- **add(T element, int index)**
- **removeAt(int index)**

В основе HashSet лежит Хэш-таблица.
```java
class Entry {
	T value; // текущий элемент
	Entry next; // сылка на цепочку следующего элемента
}
```

Алгоритмическая сложность операций в коллекции **HashSet**
Плюсы:

- Цепочка элементов в одной ячейке **O(1)**
- Вставка и удаление объекта (если без множества коллизии) **O(1).** Переписываем ссылки как в LinkedList

Минусы:

- Удаление элементов **O(N)**.
- Хэш таблица не будет уменьшаться - утечка памяти


## TreeSet
**Использовать, когда нужно, чтобы не было одинаковых элементов и они были отсортированы**

Алгоритмическая сложность одинакова для всех операций (add, remove, contains): **O(logN)**

Для работы TreeSet с самописными классами надо переопределить метод интерфейса Comparable:

**CompareTo(Car object)**

- Если наш элемент по каким-то  параметрам меньше object, то вернуть отрицательное число.
- Если наш элемент по каким-то параметрам равен object, то вернуть 0.
- Если наш элемент по каким-то параметрам больше object, то вернуть положительное число.

Если не можем перезаписывать методы в классах, то в TreesSet<>() передаем Comparator - объект анонимного класса.

Пример на основе класса **Car**

```java
Set<Car> cars = new TreeSet<>(new Comparator<Car>() {
            @Override
            public int compare(Car o1, Car o2) {
                return o1.getBrand().compareTo(o2.getBrand());
            }
        });
```

### Сходства и различия HashSet и TreeSet

**Сходства:**

- реализуют интерфейс Set
- не хранят повторяющиеся элементы

**Отличия:**

- **TreeSet** хранит объекты в отсортированном виде
- **HashSet** может хранить объекты любых классов, а **TreeSet** только тех, которые реализуют интерфейс **Comparable**, либо любых классов при условии, что в качестве параметра в конструктор был передан **Comparator**
- Алгоритмическая сложность операций вставки, удаления и поиска элемента: HashSet - **O(1)**, TreeSet - **O(logN)**

## HashMap

Хранит данные вида (ключ, значение). В качестве ключа следует использовать неизменяемый тип данных, чтобы избежать потери элемента в коллекции

Внутри есть класс Entry.

```java
class Entry {
    K key; // ключ
    V value; // значение
    Entry next; // ссылка на следующий элемент
}
```
**loadFactor = 0.75**

### Алгоритмическая сложность операций в HashMap
**Сложность всех операций в HashMap:**
- В лучшем случае - O(1)
- В худшем случае - O(log(N)). Когда связный списко достигает длины 8, то он переходит в древовидную стрктуру (как в случае с TreeSet)

### Вопросы по HashMap
- **Что представляет собой интерфейс Map?**
- - Коллекции типа Map хранят объекты парами ключ-значение
- **Основные методы в интерфейсе Map**
- - `void put(K key, V value);`
- - `V remove(K key)` - метод возвращает значение объекта, которое было удалено, или null, если удаление прошло не успешно
- - `Set<K> keySet();` - множество всех ключей
- - `List<V> values();` - список всех значений
- - `void clear();`
- - `int size();`
- **Находится ли интерфейс Map в иерархии коллекций?**
- - Нет, он не наследуется ни от интерфейса Collection, ни от интерфейса Iterable
- **Почему интерфейс Map не находится в иерархии Collections Framework?**
- - Она не может реализовать множество методов: 
- - - Метод **add** добавляет элемент в коллекцию, а **put** вставляет пару объектов
- - - Метод **remove** в обычной коллекции принимает **объект, который** нужно удалить, а в Map принимает **ключ, по которому** нужно убрать пару объектов
- **Как устроен HashMap изнутри?**
- - В основе HashMap лежит хэщ-таблица (массив из 16 элементов типа Entry). При добавлении нового объекта на основе его хэш-кода вычисляется номер позиции в хэш-таблице, куда и помещается элемент. Если там уже лежит какой-то объект, тогда с помощью метода equals проверяется не равен ли его ключ тому, что мы вставляем. Если равен, то мы перезаписываем его значение, если нет, то значит произошло коллизия.
- **Что такое коллизия, и как она разрешается в коллекции HashMap?**
- - Если у объектов с разными ключами получилась одна и та же ячейка в хэш-таблице. Эта ситуация решается созданием связного списка в той ячейке (корзине).
- **Гарантируется ли порядок элементов в HashMap?**
- - Нет, так как используется Хэш-таблица, элементы добавляются беспорядочно
- **Что произойдет, если мы добавим в HashMap пару объектов ключ-значение, при этом такой ключ уже присутствовал в коллекции, а значение лежало другое?**
- - Значение по данному ключу будет перезаписано

## Queue
Очередь, работает по принципу **FIFO** (first in first out).
Работает на основе **LinkedList**

Основные методы:
- **add(T element);** - добавляет элемент в конец очереди
- **peek();** - возвращает первый элемент в очереди или null, если очередь пустая
- **poll();** - возвращает первый элемент в очереди и удаляет его. Если очередь пустая, то будет брошено исключение
