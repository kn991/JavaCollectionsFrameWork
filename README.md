# JavaCollectionsFrameWork
Code from Stepik Java course

## Иерархия классов Collection Framework

![Иерархия.png](imagesForReadme/%D0%98%D0%B5%D1%80%D0%B0%D1%80%D1%85%D0%B8%D1%8F.png)
**Iterable** - интерфейс, который позволяет перебирать элементы коллекции циклом for each

**Collection** - интерфейс, от которого наследуются Set и List

Основные реализации List:
- **ArrayList**
- **LinkedList**

Основные реализации Set:
- **HashSet**
- **TreeSet**

## ArrayList (динамический массив)
Алгоритмическая сложность операций в коллекции **ArrayList**

Плюсы:
- Получение элемента по индексу - **O(1)**
- Вставка элемента в конец списка - **O(1)**

Минусы:
- Удаление элемента - **O(N)**
- Вставка элемента в середину или начало списка - **O(N)**
- При удалении элементов мы не меняем размер массива, только меняем size. Может возникнуть утечка памяти


## LinkedList (Связный список)
Внутри LinkedList есть класс Node

```java
class Node {
	Node previous; // предыдущий элемент
	T value; // текущий элемент (значение)
	Node next; // следующий элемент 
}
```
Алгоритмическая сложность операций в коллекции **LinkedList**

Плюсы:
- Вставка в начало, середину или конец коллекции- **O(1)**
- Удаление элемента из коллекции - **O(1)**

Минусы:
- Получение элемента по индексу - **O(n)**

## HashSet (Хэш-таблица)

**### !!! В HashSet нет методов, обращающихся к элементу по индексу, таких как:**
- **get(index)**
- **add(T element, int index)**
- **removeAt(int index)**

В основе HashSet лежит Хэш-таблица.
```java
class Entry {
	T value; // текущий элемент
	Entry next; // сылка на цепочку следующего элемента
}
```

Алгоритмическая сложность операций в коллекции **HashSet**
Плюсы:

- Цепочка элементов в одной ячейке **O(1)**
- Вставка и удаление объекта (если без множества коллизии) **O(1).** Переписываем ссылки как в LinkedList

Минусы:

- Удаление элементов **O(N)**.
- Хэш таблица не будет уменьшаться - утечка памяти


## TreeSet
**Использовать, когда нужно, чтобы не было одинаковых элементов и они были отсортированы**

Алгоритмическая сложность одинакова для всех операций (add, remove, contains): **O(logN)**

Для работы TreeSet с самописными классами надо переопределить метод интерфейса Comparable:

**CompareTo(Car object)**

- Если наш элемент по каким-то  параметрам меньше object, то вернуть отрицательное число.
- Если наш элемент по каким-то параметрам равен object, то вернуть 0.
- Если наш элемент по каким-то параметрам больше object, то вернуть положительное число.

Если не можем перезаписывать методы в классах, то в TreesSet<>() передаем Comparator - объект анонимного класса.

Пример на основе класса **Car**

```java
Set<Car> cars = new TreeSet<>(new Comparator<Car>() {
            @Override
            public int compare(Car o1, Car o2) {
                return o1.getBrand().compareTo(o2.getBrand());
            }
        });
```

### Сходства и различия HashSet и TreeSet

**Сходства:**

- реализуют интерфейс Set
- не хранят повторяющиеся элементы

**Отличия:**

- **TreeSet** хранит объекты в отсортированном виде
- **HashSet** может хранить объекты любых классов, а **TreeSet** только тех, которые реализуют интерфейс **Comparable**, либо любых классов при условии, что в качестве параметра в конструктор был передан **Comparator**
- Алгоритмическая сложность операций вставки, удаления и поиска элемента: HashSet - **O(1)**, TreeSet - **O(logN)**